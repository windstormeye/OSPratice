##### 本文章仅为记录一些容易遗忘的内容所用


### 实验二 
本次实验依据指导书中要求的内容，主要是基于之前实验一中熟悉了基本linux环境后，在此基础之上进行的加深，主要实验要达到主要目的是

1、熟悉在LINUX环境下如何使用命令方式完成自己的工作；

2、作为普通用户如何对目录和文件进行管理；

3、如何通过对SHELL环境变量的设置调整自己的工作环境。

</br>

___

</br>

以上就是本次实验要达到的主要内容，具体要实现的功能如下所示：

##### ①	在用户家目录下创建名为test的目录；
```shell
cd /home/pjpjpj(pjpjpj是我的！不是你哒！)
mkdir test
```
这里一点需要注意的地方，mkdir是创建文件夹，而不是创建文件，创建文件的可以直接

```shell
vi fileName
# 写完东西后，就可以直接在vi中按下esc，再输入:wq保存即可
# 或者可以直接
touch fileName
# 还有其它方式，不过我觉得不太好🙂
```

②	将工作目录改到test；

```shell 
cd test
# 需要注意，必须保证test这个工作目录是存在的，否则根本进不去
```
③	执行pwd命令，确定当前工作目录；

```shell
pwd
# 执行完这条目录后，如果没错的话，应该会输出
# /home/pjpjpj/test
```
④	使用cd命令，将工作目录改到根（/）上；

```shell
cd /
```
⑤	直接使用cd，回到哪儿了？用pwd验证；

```shell
qwd
# 此时会给你输出 /
```

⑥	进入①创建的子目录test，执行命令man date > file1完成了什么操作？再执行cat file1，看到什么？ 

```shell
cd test
man date > file1
# > 是重定向的意思，就是说，把date命令的帮助文档内容重定向输入到了file1文件中
# 使用 > 重定向，也是创建文件的一个方式（不过，我一般不这么用
# man 是查看跟在其后边的命令的使用帮助信息，如果你不知道man命令怎么用，那就man man好了
cat file1
# cat 命令能够直接把这个文件中的信息一次性的全部打印出来
# 或者你还可以使用 vi file1，通过vi编辑器也能够看到file1中的内容
# ps:vim和vi可不一样，vim比vi高级多了。2333
```

⑦	复制文件file1到file2，将file2重命名为file3，执行cat f*的结果是什么？

```shell
cp file1 file2
mv file2 file3
# 文件重命名还可使用 rename命令，个人觉得mv比较方便而已（少打了4个字符。2333
# 不过小心跨目录移动文件且重命名时，若该目录下已存在想要修改的文件名文件
# 我们再修改移动过去是会覆盖原目录下文件的
cat f*
# 会按字典序打印出所有文件名前缀为f的文件
```

⑧	比较file1和file3两个文件是否相同？如何得到比较结果？对file3做少量修改后再比较，输出结果是什么？  

```shell 
diff file1 file3
# 如果diff命令后不跟任何参数，那么会给你直接打印出来参与对比的两个文件中那行有不同
# 如果我们转化一下，给多加一个参数 -s
diff file1 file3 -s
# 这样就会非常的简单的打印出一句话告诉你file1和file3一样还是不一样。
```

⑨	执行命令cat file1 | head –20 | tee file5和cat file5 | wc的结果如何？对wc命令分别使用-l、-c、-w选项后输出结果又如何？

```shell
cat file1 | head -20 | tee file5
# | 是shell中的管道符，能够传递 | 之前命令中筛选出来的内容
# head -20 取file1文件中头20行的内容
# tee 不但可以在terminal中看到文件信息，还能够把这些信息写入file5中
# 总的来说就是，把file1中的头20行输入到file5文件中，并且能够在terminal中看见
cat file5 | wc
# wc 是word Count命令的简单，用来做文件信息统计的
# 执行该条命令后，直接在terminal中打印出file5文件中的字节数、字数、行数
cat file5 | wc -l
# 统计file5文件中的行数
cat file5 | wc -c
# 统计file5文件中的字节数
cat file5 | wc -w
# 统计file5文件的中的字数
```

⑩	将df命令帮助文档中所有包含"inode"的行写入文件a；

```shell
man df | grep 'inode' > a
# grep 是短语全局正则表达式打印的简写，我们能够利用该命令去洗掉一些不想要的脏数据 
```

⑪	将df命令帮助文档中所有不包含"system"或"block"的行写入文件b；

```shell
man df | grep -v 'system' > b
man df | grep -v 'block' > b
# grep -v 参数代表反向选择，也就是不搜索
```

⑫	将df命令输出结果的最后一列进行抽取，并过滤题头“挂载点”。将抽取、过滤后的信息写入文件c；

```shell
df | awk '{print $NF}' | sed '1d' > c
# df 显示磁盘的相关信息，说的再多也没用，直接在terminal中输入df即可看到的效果
# awk 是一个文本分析工具，你可以用grep进行信息的查找及筛选，用awk可以生成一些格式化数据
# sed 是一个流编辑工具，常用于文本编辑，当我们把数据都读到缓冲区时，可用sed命令进行处理
#  awk '{print $NF}' 打印出最后一列信息，$NF表示最后一列
# sed '1d' 删除第一行
```

⑬	运行ln  a  ../d1和ln  -s  a  ../d2，再运行ls  –l  a看链接计数有无变化？用cat 命令显示文件d2的内容。分别改变文件d1和d2的权限，有何变化？文件a的权限有无变化？为什么？

```shell
# 为了更好的方便证明链接计数，我们首先来看一遍a文件的链接计数
ls  –l  a
# 此时可以看到 a的链接计数为1
ln  a  ../d1
# ln 为a文件在当前文件（.）的父目录（..）下的d1文件建立硬连接
ls  –l  a
# 此时可以看到 a的链接计数变为2
ln  -s  a  ../d2
# ln 为a文件在当前文件（.）的父目录（..）下的d2文件建立软连接
ls  –l  a
# 此时可以看到 a的链接计数还是2
ls  –l  a d1 d2
# 此时可以看到，a文件的链接计数为2
# d1文件的链接计数为2
# d2文件的链接计数为1
# 得出结论：硬链接会让原文件与链接文件的链接计数+1
# 软链接不会让原文件与链接文件的链接计数+1
cat d2
# d2的文件内容与a文件完全一致
chmod 777 d1
chmod 111 d2
# -w == 4
# -r == 2
# -x == 1，所以777是
# 对这个文件的所有者可读可写可执行操作
# 对该文件所有者的同一用户组的用户可读可写可执行
# 对其它用户可读可写可执行
# 执行完以上两部修改文件的操作后，a文件的权限会由777变为111
# 也就是说，软硬链接后的文件的任何修改都会直接影响到原文件，反过来也是一样的
# 不过，如果你执行了 ls -li a ../d1 ../d2后，会发现
# 其实d1和a文件的inode指针是指向同一个内存空间的，而d2不是
# 因此，如果你把原文件删掉，d1这个硬链接文件还在，而d2也被删了
# 再次总结：硬链接与原文件毫无区别，可以认为是对原文件做了一个备份，因为inode指针所指向的内存区域都是同一块
# 软连接只是原文件的一个快捷方式，当我们访问软链接文件，其实是访问了原文件，其只是做了保存了一个绝对路径指向原文件待的地方而已
```





